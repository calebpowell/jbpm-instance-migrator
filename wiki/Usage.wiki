#summary jbpm-instance-migrator usage

= Introduction =

The following page explains how to use the jbpm-instance-migrator library. 

* Defining a Migration

Migrations are written as Java classes. The class must implement the org.jbpm.instance.migration.Migration interface, it must not be abstract, and it must contain a default constructor. The Migration interface declares one method that must be implemented called 'createNodeMap()', whose return value is an instance of a StateNodeMap. A StateNodeMap is used by a migrator to determine which nodes have been deprecated and which nodes have superseded the deprecated nodes. In the following __ApplicationProcessMigration001__ migration, the __init__ node has been deprecate and superseded by the __start__ node:

{{{
public class ApplicationProcessMigration001 implements Migration{
   
   public StateNodeMap createNodeMap() {
       return new StateNodeMap(new String[][]{
               {"init", "start"}       
       });
   }
}

}}}

* Defining a Migrator

A Migrator can be created and used as follows:

{{{
Migrator migrator = new Migrator(“ApplicationProcess”, jbpmContext, “com.foobar.ApplicationProcessMigration”);
ProcessInstance newProcessInstance = migrator.migrate(oldProcessInstance);
}}}

The parameters used to create the Migrator instance are:

  # The name of the Process Definition that it will be migrating.
  # A JbpmContext instance. The migrator requires this to look up the latest Process Definition.
  # The Migration base class name. The migrator assumes that your migrations use the pattern __package.ClassName{migration#}__. For the base Class name “com.foobar.ApplicationProcessMigration”, the migrator will attempt to load and instantiate classes named “com.foobar.ApplicationProcessMigration001”, “com.foobar.ApplicationProcessMigration002”, etc, until it can’t find any valid classes.
